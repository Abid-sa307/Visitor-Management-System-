@extends('layouts.sb')

@section('content')
<div class="container d-flex justify-content-center mt-5">
  <div class="card shadow-lg p-4 w-100" style="max-width: 800px;">
    <h3 class="mb-4 text-center fw-bold text-primary">
      Register New Visitor
    </h3>

    @if ($errors->any())
      <div class="alert alert-danger">
        <strong>Please fix the errors below.</strong>
        <ul class="mb-0 mt-2 small">
          @foreach ($errors->all() as $error)
            <li>{{ $error }}</li>
          @endforeach
        </ul>
      </div>
    @endif

    <form action="{{ auth()->user()->role === 'company' ? route('company.visitors.store') : route('visitors.store') }}" 
        method="POST" enctype="multipart/form-data" id="visitorForm">
      @csrf
      
      <!-- Hidden field for face encoding -->
      <input type="hidden" name="face_image" id="faceImageInput">

      <div class="row">
        <!-- Left Column -->
        <div class="col-md-6">
          <!-- Phone -->
          <div class="mb-3">
            <label class="form-label fw-semibold">Phone Number <span class="text-danger">*</span></label>
            <input type="text" name="phone" id="phoneInput" class="form-control @error('phone') is-invalid @enderror" required 
                   value="{{ old('phone') }}" placeholder="Enter mobile number" autofocus>
            @error('phone')
              <div class="invalid-feedback d-block">{{ $message }}</div>
            @enderror
          </div>
          <div id="autofillHint" class="alert alert-info py-2 px-3 d-none">
            A previous visitor with this number was found.
            <button type="button" id="autofillBtn" class="btn btn-sm btn-primary ms-2">Autofill name & email</button>
          </div>

          <!-- Name -->
          <div class="mb-3">
            <label class="form-label fw-semibold">Full Name <span class="text-danger">*</span></label>
            <input type="text" name="name" id="nameInput" class="form-control @error('name') is-invalid @enderror" 
                   required value="{{ old('name') }}" placeholder="Enter full name">
            @error('name')
              <div class="invalid-feedback d-block">{{ $message }}</div>
            @enderror
          </div>

          <!-- Email -->
          <div class="mb-3">
            <label class="form-label fw-semibold">Email</label>
            <input type="email" name="email" id="emailInput" class="form-control @error('email') is-invalid @enderror" 
                   value="{{ old('email') }}" placeholder="Enter email (optional)">
            @error('email')
              <div class="invalid-feedback d-block">{{ $message }}</div>
            @enderror
          </div>

          <!-- Hidden department_id field to prevent error -->
          <input type="hidden" name="department_id" value="">
          <input type="hidden" name="purpose" value="General Inquiry">

          <!-- Documents -->
          <div class="mb-3">
            <label class="form-label fw-semibold">Documents (optional)</label>
            <input type="file" name="documents[]" class="form-control @error('documents.*') is-invalid @enderror" multiple>
            @error('documents.*')
              <div class="invalid-feedback d-block">{{ $message }}</div>
            @enderror
          </div>

          <!-- Simple Photo Upload -->
          <div class="mb-3">
            <label class="form-label fw-semibold">Visitor Photo</label>
            <div class="d-flex align-items-center gap-3">
              <div class="position-relative">
                <img id="photoPreview" src="{{ asset('images/default-avatar.png') }}" 
                     class="rounded border" 
                     style="width: 80px; height: 80px; object-fit: cover;" 
                     alt="Visitor Photo">
                <input type="file" name="photo" id="photo_upload" 
                       accept="image/*" class="d-none" 
                       onchange="previewPhoto(this)">
              </div>
              <div>
                <button type="button" class="btn btn-outline-primary btn-sm" onclick="document.getElementById('photo_upload').click()">
                  <i class="fas fa-camera me-1"></i> Add Photo
                </button>
                <div class="text-muted small mt-1">JPG, PNG, max 2MB</div>
                @error('photo')
                  <div class="text-danger small">{{ $message }}</div>
                @enderror
              </div>
            </div>
          </div>
        </div>

        <!-- Right Column -->
        <div class="col-md-6">
          <!-- Face Registration -->
          <div class="card mb-3">
            <div class="card-header bg-light">
              <h6 class="mb-0">Face Registration <span class="text-danger">*</span></h6>
            </div>
            <div class="card-body text-center">
              <div class="camera-container mb-3" style="max-width: 500px; margin: 0 auto; border: 2px solid #ddd; border-radius: 8px; overflow: hidden;">
                <video id="video" autoplay playsinline style="width: 100%; display: none;"></video>
                <canvas id="canvas" style="display: none; width: 100%;"></canvas>
              </div>
              
              <div id="cameraStatus" class="mb-3">
                Click 'Start Camera' to begin
              </div>
              
              <div class="mb-3">
                <button type="button" id="startBtn" class="btn btn-primary">
                  <i class="fas fa-camera me-2"></i> Start Camera
                </button>
                <button type="button" id="captureBtn" class="btn btn-success" disabled>
                  <i class="fas fa-camera me-2"></i> Capture
                </button>
                <button type="button" id="retakeBtn" class="btn btn-warning" disabled>
                  <i class="fas fa-redo me-2"></i> Retake
                </button>
              </div>
              
              <div id="previewContainer" class="mt-3" style="display: none;">
                <p class="text-muted small mb-2">Preview:</p>
                <img id="preview" class="img-thumbnail" style="max-width: 200px;">
              </div>
              
              <!-- Hidden input to store the captured image -->
              <input type="hidden" name="face_image" id="faceImageInput">
            </div>
                  Please capture your face before submitting.
                </div>
              </div>
            </div>
          </div>

          <!-- Preview -->
          <div class="card">
            <div class="card-header bg-light">
              <h6 class="mb-0">Preview</h6>
            </div>
            <div class="card-body text-center">
              <div id="previewContainer" class="mb-3" style="display: none;">
                <img id="preview" src="#" alt="Captured Face" class="img-fluid rounded" style="max-height: 200px;">
              </div>
              <div id="noPreview" class="text-muted">
                Face preview will appear here
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Submit Button -->
      <div class="d-grid gap-2 mt-4">
        <button type="submit" class="btn btn-primary btn-lg">
          <i class="fas fa-user-plus me-2"></i> Register Visitor
        </button>
      </div>
    </form>
  </div>
</div>

@push('styles')
<style>
  /* Camera Styles */
  .camera-container {
    width: 100%;
    max-width: 500px;
    margin: 0 auto 20px;
    border: 2px solid #ddd;
    border-radius: 8px;
    overflow: hidden;
  }
  
  #videoElement {
    width: 100%;
    display: block;
  }
  
  #canvasElement {
    display: none;
    width: 100%;
  }
  
  .camera-buttons {
    margin: 15px 0;
    text-align: center;
  }
  
  .camera-buttons .btn {
    margin: 0 5px;
    min-width: 120px;
  }
  
  #cameraStatus {
    min-height: 24px;
    margin: 10px 0;
    text-align: center;
    font-size: 0.9em;
  }
  
  #previewImage {
    max-width: 100%;
    border-radius: 4px;
    margin-top: 10px;
  }
</style>
@endpush

@push('scripts')
<script>
// DOM Elements
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const startBtn = document.getElementById('startBtn');
const captureBtn = document.getElementById('captureBtn');
const retakeBtn = document.getElementById('retakeBtn');
const preview = document.getElementById('preview');
const previewContainer = document.getElementById('previewContainer');
const statusElement = document.getElementById('cameraStatus');
const faceImageInput = document.getElementById('faceImageInput');
        return false;
    }
    
    try {
        // First stop any existing streams
        if (window.cameraStream) {
            window.cameraStream.getTracks().forEach(track => track.stop());
        }
        
        // Try to get camera access
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: {
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user'
            },
            audio: false
        });
        
        // Store the stream globally
        window.cameraStream = stream;
        
        // Show camera feed
        video.srcObject = stream;
        video.play();
        
        // Make sure video is visible
        video.style.display = 'block';
        
        // Update status
        if (status) {
            status.textContent = 'Camera is working!';
            status.className = 'mt-2 small text-success';
        }
        
        return true;
        
    } catch (error) {
        console.error('Camera Error:', error);
        if (status) {
            status.textContent = 'Camera Error: ' + (error.message || 'Could not access camera');
            status.className = 'mt-2 small text-danger';
        }
        return false;
    }
}

// Simple photo preview function
// Simple camera test function
async function testCamera() {
    const video = document.getElementById('video');
    const status = document.getElementById('faceCaptureStatus');
    
    if (!video) {
        console.error('Video element not found');
        return false;
    }
    
    try {
        // Try to get camera access
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user' 
            } 
        });
        
        // Show camera feed
        video.srcObject = stream;
        video.style.display = 'block';
        
        // Update status
        if (status) {
            status.textContent = 'Camera is working! Now testing face detection...';
            status.className = 'mt-2 small text-success';
        }
        
        // Keep the stream reference
        window.testStream = stream;
        
        return true;
        
    } catch (error) {
        console.error('Camera error:', error);
        if (status) {
            status.textContent = 'Camera error: ' + (error.message || 'Could not access camera');
            status.className = 'mt-2 small text-danger';
        }
        return false;
    }
}
// Simple photo preview function
function previewPhoto(input) {
    const preview = document.getElementById('photoPreview');
    const file = input.files[0];
    
    if (file) {
        // Check file size (2MB max)
        if (file.size > 2 * 1024 * 1024) {
            alert('File size should not exceed 2MB');
            input.value = ''; // Clear the file input
            return;
        }
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
            preview.src = e.target.result;
            // Also update the face image input for form submission
            document.getElementById('faceImageInput').value = e.target.result;
            
            // Update the preview in the face detection section
            const previewImg = document.getElementById('preview');
            if (previewImg) {
                previewImg.src = e.target.result;
                document.getElementById('previewContainer').style.display = 'block';
                document.getElementById('noPreview').style.display = 'none';
            }
        }
        
        reader.onerror = function() {
            alert('Error reading the file');
            input.value = ''; // Clear the file input
        };
        
        reader.readAsDataURL(file);
    }
}

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    console.log('Page loaded, initializing...');
    
    // Set default photo if needed
    const photoInput = document.getElementById('photo_upload');
    if (photoInput && photoInput.files.length === 0) {
        const preview = document.getElementById('photoPreview');
        if (preview) {
            preview.src = "{{ asset('images/default-avatar.png') }}";
        }
    }
    
    // Set up camera button
    const startBtn = document.getElementById('startCameraBtn');
    if (startBtn) {
        startBtn.addEventListener('click', async function() {
            console.log('Start Camera button clicked');
            startBtn.disabled = true;
            startBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Starting...';
            
            try {
                await initCamera();
            } catch (error) {
                console.error('Error starting camera:', error);
                const status = document.getElementById('faceCaptureStatus');
                if (status) {
                    status.textContent = 'Error: ' + (error.message || 'Failed to start camera');
                    status.className = 'mt-2 small text-danger';
                }
            } finally {
                startBtn.disabled = false;
                startBtn.innerHTML = '<i class="fas fa-camera me-2"></i> Start Camera';
            }
        });
        
        // Enable the start button
        startBtn.disabled = false;
    }
    
    // Set default photo
    const photoInput = document.getElementById('photo_upload');
    if (photoInput && photoInput.files.length === 0) {
        const preview = document.getElementById('photoPreview');
        if (preview) {
            preview.src = "{{ asset('images/default-avatar.png') }}";
        }
    }
    
    // Set up camera button event listener
    const startBtn = document.getElementById('startCameraBtn');
    if (startBtn) {
        console.log('Start button found, adding click listener');
        startBtn.addEventListener('click', async function() {
            console.log('Start Camera button clicked');
            try {
                await startCamera();
            } catch (error) {
                console.error('Error in startCamera:', error);
                updateFaceStatus('Failed to start camera: ' + (error.message || 'Unknown error'), 'error');
            }
        });
        
        // Enable the button initially
        startBtn.disabled = false;
    } else {
        console.error('Start button not found!');
    }
    
    // Set up retake button event listener
    const retakeBtn = document.getElementById('retakeBtn');
    if (retakeBtn) {
        retakeBtn.addEventListener('click', function() {
            console.log('Retake button clicked');
            // Reset UI
            document.getElementById('video').style.display = 'block';
            document.getElementById('canvas').style.display = 'none';
            document.getElementById('previewContainer').style.display = 'none';
            document.getElementById('noPreview').style.display = 'block';
            document.getElementById('faceImageInput').value = '';
            
            // Reset buttons
            retakeBtn.classList.add('d-none');
            startBtn.classList.remove('d-none');
            
            // Stop any ongoing detection
            isDetecting = false;
            
            // Restart camera
            startCamera();
        });
    }
    
    // Load face detection models
    loadFaceModels();
});

// Clean up camera when leaving the page
window.addEventListener('beforeunload', function() {
    if (window.cameraStream) {
        window.cameraStream.getTracks().forEach(track => track.stop());
    }
});

// Load face detection models
async function loadFaceModels() {
    try {
        console.log('Starting to load face detection models...');
        // Set the models path
        const MODEL_URL = '{{ asset("models") }}';
        console.log('Models path:', MODEL_URL);
        
        // Show loading state
        updateFaceStatus('Loading face detection models...', 'info');
        
        // Check if face-api is loaded
        if (typeof faceapi === 'undefined') {
            throw new Error('face-api.js is not loaded. Check the script source.');
        }
        
        // Load models with error handling for each
        try {
            console.log('Loading TinyFaceDetector model...');
            await faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL);
            console.log('TinyFaceDetector loaded');
            
            console.log('Loading FaceLandmark68Net model...');
            await faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL);
            console.log('FaceLandmark68Net loaded');
            
            console.log('Loading FaceRecognitionNet model...');
            await faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL);
            console.log('FaceRecognitionNet loaded');
            
            modelsLoaded = true;
            console.log('All face detection models loaded successfully');
            updateFaceStatus('Face detection ready. Click Start Camera to begin.', 'success');
            
            return true;
            
        } catch (modelError) {
            console.error('Error loading face detection model:', modelError);
            updateFaceStatus('Error loading face detection model: ' + modelError.message, 'error');
            return false;
        }
        
    } catch (error) {
        console.error('Error in loadFaceModels:', error);
        updateFaceStatus('Error initializing face detection: ' + (error.message || 'Unknown error'), 'error');
        return false;
    }
}

// Start camera for face detection (will be re-added after basic camera works)
async function startFaceDetection() {
    console.log('Starting face detection...');
    // We'll add this back once basic camera is working
    
    // Disable start button while initializing
    if (startBtn) {
        startBtn.disabled = true;
        startBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Starting...';
    }
    
    try {
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const startBtn = document.getElementById('startCameraBtn');
        const retakeBtn = document.getElementById('retakeBtn');
        
        if (!video || !canvas) {
            throw new Error('Video or canvas element not found');
        }
        
        console.log('Requesting camera access...');
        // Request camera access
        stream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user' 
            } 
        });
        
        console.log('Camera access granted, setting up video...');
        // Set video source and play
        video.srcObject = stream;
        
        // Wait for video to be ready
        await new Promise((resolve) => {
            video.onloadedmetadata = () => {
                video.play().then(resolve).catch(error => {
                    console.error('Error playing video:', error);
                    throw new Error('Could not start video playback');
                });
            };
        });
        
        console.log('Video is playing, setting up UI...');
        // Show video and hide canvas
        video.style.display = 'block';
        canvas.style.display = 'none';
        
        // Toggle buttons
        if (startBtn) startBtn.classList.add('d-none');
        if (retakeBtn) retakeBtn.classList.remove('d-none');
        
        // Start face detection
        console.log('Starting face detection...');
        detectFaces();
        
    } catch (error) {
        console.error('Error in startCamera:', error);
        updateFaceStatus(`Error: ${error.message || 'Could not access camera. Please ensure you have granted camera permissions.'}`, 'error');
        
        // Re-enable start button on error
        const startBtn = document.getElementById('startCameraBtn');
        if (startBtn) startBtn.classList.remove('d-none');
    }
}

// Detect faces in the video stream
async function detectFaces() {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    
    if (!video || !canvas) return;
    
    // Set canvas size to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    const displaySize = { width: video.videoWidth, height: video.videoHeight };
    faceapi.matchDimensions(canvas, displaySize);
    
    // Start detection loop
    isDetecting = true;
    
    async function detect() {
        if (!isDetecting) return;
        
        try {
            // Detect all faces in the video
            const detections = await faceapi.detectAllFaces(
                video, 
                new faceapi.TinyFaceDetectorOptions()
            ).withFaceLandmarks().withFaceDescriptors();
            
            // Clear canvas
            const context = canvas.getContext('2d');
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw detections
            const resizedDetections = faceapi.resizeResults(detections, displaySize);
            faceapi.draw.drawDetections(canvas, resizedDetections);
            faceapi.draw.drawFaceLandmarks(canvas, resizedDetections);
            
            // If a face is detected, capture it after a short delay
            if (detections.length > 0) {
                updateFaceStatus('Face detected! Capturing in 2 seconds...', 'info');
                
                // Wait 2 seconds to ensure face is stable
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Capture the face
                await captureFace();
                return; // Stop detection after capture
            } else {
                updateFaceStatus('Position your face in the frame', 'info');
            }
            
            // Continue detection
            requestAnimationFrame(detect);
            
        } catch (error) {
            console.error('Error detecting faces:', error);
            updateFaceStatus('Error detecting faces', 'error');
        }
    }
    
    // Start detection loop
    detect();
}

// Capture face and process it
async function captureFace() {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const preview = document.getElementById('preview');
    const previewContainer = document.getElementById('previewContainer');
    const noPreview = document.getElementById('noPreview');
    const faceImageInput = document.getElementById('faceImageInput');
    
    if (!video || !canvas || !preview || !faceImageInput) return;
    
    try {
        // Stop detection
        isDetecting = false;
        
        // Get the face descriptor
        const detections = await faceapi.detectAllFaces(
            video, 
            new faceapi.TinyFaceDetectorOptions()
        ).withFaceLandmarks().withFaceDescriptors();
        
        if (detections.length === 0) {
            updateFaceStatus('No face detected. Please try again.', 'error');
            return;
        }
        
        // Get the first face
        const detection = detections[0];
        
        // Convert descriptor to array for storage
        const faceDescriptor = Array.from(detection.descriptor);
        
        // Store the face encoding
        faceImageInput.value = JSON.stringify(faceDescriptor);
        
        // Draw the captured face on canvas
        const context = canvas.getContext('2d');
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        // Show the captured image in preview
        const imageData = canvas.toDataURL('image/jpeg');
        preview.src = imageData;
        
        // Update UI
        video.style.display = 'none';
        canvas.style.display = 'block';
        previewContainer.style.display = 'block';
        noPreview.style.display = 'none';
        
        // Stop the camera stream
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
            stream = null;
        }
        
        updateFaceStatus('Face captured successfully!', 'success');
        
    } catch (error) {
        console.error('Error capturing face:', error);
        updateFaceStatus('Error capturing face', 'error');
    }
}

// Update face detection status
function updateFaceStatus(message, type = 'info') {
    const statusElement = document.getElementById('faceCaptureStatus');
    if (!statusElement) return;
    
    statusElement.textContent = message;
    statusElement.className = 'mt-2 small ' + 
        (type === 'error' ? 'text-danger' : 
         type === 'success' ? 'text-success' : 'text-info');
}

// Stop camera when navigating away
window.addEventListener('beforeunload', function() {
    console.log('Page unload - cleaning up camera...');
    if (stream) {
        stream.getTracks().forEach(track => {
            console.log('Stopping track:', track.kind);
            track.stop();
        });
        stream = null;
    }
    isDetecting = false;
});

// Stop camera and clean up
function stopCamera() {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
    }
    
    if (detectionInterval) {
        clearInterval(detectionInterval);
        detectionInterval = null;
    }
}

// Event listeners
document.addEventListener('DOMContentLoaded', function() {
    const startBtn = document.getElementById('startCameraBtn');
    const retakeBtn = document.getElementById('retakeBtn');
    
    if (startBtn) {
        startBtn.addEventListener('click', startCamera);
    }
    
    if (retakeBtn) {
        retakeBtn.addEventListener('click', () => {
            document.getElementById('video').style.display = 'block';
            document.getElementById('canvas').style.display = 'none';
            retakeBtn.classList.add('d-none');
            startBtn.classList.remove('d-none');
            startCamera();
        });
    }
    
    // Stop camera when navigating away
    window.addEventListener('beforeunload', stopCamera);
});
  
  // Lightweight phone lookup & autofill (name, email only)
  function companyPrefix(){ 
    return window.location.pathname.startsWith('/company') ? '/company' : ''; 
  }
  
  // Debounce function to limit API calls
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  
  async function lookupByPhone(phone) {
    const trimmedPhone = phone ? phone.trim() : '';
    
    // Clear previous data if phone is empty or too short
    if (!trimmedPhone || trimmedPhone.length < 5) { 
      if (hint) hint.classList.add('d-none'); 
      lookupData = null; 
      return null;
    }
    
    // Show loading state
    if (hint) {
      hint.innerHTML = 'Checking visitor history... <div class="spinner-border spinner-border-sm" role="status"></div>';
      hint.classList.remove('d-none', 'alert-info');
      hint.classList.add('alert-secondary');
    }
    
    try {
      const response = await fetch(`${companyPrefix()}/visitors/lookup?phone=${encodeURIComponent(trimmedPhone)}`, {
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest'
        }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      lookupData = data || null;
      
      if (hint) {
        if (lookupData) {
          hint.innerHTML = `Previous visitor found. <button type="button" id="autofillBtn" class="btn btn-sm btn-primary ms-2">Autofill details</button>`;
          hint.classList.remove('alert-secondary');
          hint.classList.add('alert-info');
          
          // Re-attach the event listener to the new button
          const newAutofillBtn = hint.querySelector('#autofillBtn');
          if (newAutofillBtn) {
            newAutofillBtn.addEventListener('click', () => {
              if (!lookupData) return;
              
              const nameEl = document.getElementById('nameInput');
              const emailEl = document.getElementById('emailInput');
              
              if (nameEl && (lookupData.name ?? '') !== '') nameEl.value = lookupData.name;
              if (emailEl && (lookupData.email ?? '') !== '') emailEl.value = lookupData.email;
              
              hint.classList.add('d-none');
            });
          }
        } else {
          hint.classList.add('d-none');
        }
      }
      
      return lookupData;
      
    } catch (error) {
      console.error('Error looking up visitor:', error);
      lookupData = null;
      
      if (hint) {
        hint.innerHTML = 'Error checking visitor history. You can continue with manual entry.';
        hint.classList.remove('alert-info', 'alert-secondary');
        hint.classList.add('alert-warning');
        
        // Hide the hint after 5 seconds
        setTimeout(() => {
          if (hint) hint.classList.add('d-none');
        }, 5000);
      }
      
      return null;
    }
  }

  // Phone input events with debounced lookup
  // Phone number lookup
  const phoneInput = document.getElementById('phoneInput');
  const nameInput = document.getElementById('nameInput');
  const emailInput = document.getElementById('emailInput');
  const autofillHint = document.getElementById('autofillHint');
  const autofillBtn = document.getElementById('autofillBtn');

  // Add form submission handler
  const form = document.getElementById('visitorForm');
  if (form) {
    form.addEventListener('submit', async function(e) {
      e.preventDefault();
      
      const faceEncodingInput = document.getElementById('faceEncodingInput');
      const faceImageInput = document.getElementById('faceImageInput');
      
      // Debug: Log the current state of the inputs
      console.log('Form submission - Face encoding input:', {
        exists: !!faceEncodingInput,
        hasValue: faceEncodingInput ? !!faceEncodingInput.value : false,
        valueLength: faceEncodingInput ? faceEncodingInput.value.length : 0,
        valuePreview: faceEncodingInput ? faceEncodingInput.value.substring(0, 50) + '...' : null
      });
      
      // Check if face encoding is required but not set
      if (faceEncodingInput && !faceEncodingInput.value) {
        // Show error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'alert alert-danger mt-3';
        errorDiv.textContent = 'Please capture your face before submitting the form.';
        
        // Insert after the form
        form.parentNode.insertBefore(errorDiv, form.nextSibling);
        
        // Scroll to the error message
        errorDiv.scrollIntoView({ behavior: 'smooth' });
        
        // Remove the error message after 5 seconds
        setTimeout(() => {
          errorDiv.remove();
        }, 5000);
        
        return false;
      }
      
      // Show loading state
      const submitButton = form.querySelector('button[type="submit"]');
      const originalButtonText = submitButton.innerHTML;
      submitButton.disabled = true;
      submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
      
      // Create a new FormData object to ensure all fields are included
      const formData = new FormData(form);
      
      // Explicitly set the face_encoding and face_image values if they exist
      if (faceEncodingInput && faceEncodingInput.value) {
        formData.set('face_encoding', faceEncodingInput.value);
      }
      
      if (faceImageInput && faceImageInput.value) {
        formData.set('face_image', faceImageInput.value);
      }
      
      // Log the form data before submission
      const formDataObj = {};
      formData.forEach((value, key) => {
        formDataObj[key] = key === 'face_encoding' || key === 'face_image' ? 
          (value ? '[' + value.length + ' characters]' : 'empty') : value;
      });
      
      console.log('Submitting form with data:', {
        hasFaceEncoding: !!faceEncodingInput?.value,
        faceEncodingLength: faceEncodingInput?.value?.length || 0,
        hasFaceImage: !!faceImageInput?.value,
        faceImageLength: faceImageInput?.value?.length || 0,
        formData: formDataObj
      });
      
      try {
        const response = await fetch(form.action, {
          method: 'POST',
          body: formData,
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
            'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content')
          }
        });
        
        const result = await response.json();
        
        if (response.ok) {
          // Redirect on success
          if (result.redirect) {
            window.location.href = result.redirect;
          } else {
            window.location.href = '/visitors';
          }
        } else {
          // Show error message
          const errorDiv = document.createElement('div');
          errorDiv.className = 'alert alert-danger mt-3';
          errorDiv.textContent = result.message || 'An error occurred. Please try again.';
          form.parentNode.insertBefore(errorDiv, form.nextSibling);
          
          // Re-enable the submit button
          submitButton.disabled = false;
          submitButton.innerHTML = originalButtonText;
          
          // Scroll to the error message
          errorDiv.scrollIntoView({ behavior: 'smooth' });
          
          // Remove the error message after 5 seconds
          setTimeout(() => {
            errorDiv.remove();
          }, 5000);
        }
      } catch (error) {
        console.error('Error submitting form:', error);
        
        // Show error message
        const errorDiv = document.createElement('div');
        errorDiv.className = 'alert alert-danger mt-3';
        errorDiv.textContent = 'An error occurred while submitting the form. Please try again.';
        form.parentNode.insertBefore(errorDiv, form.nextSibling);
        
        // Re-enable the submit button
        submitButton.disabled = false;
        submitButton.innerHTML = originalButtonText;
        
        // Scroll to the error message
        errorDiv.scrollIntoView({ behavior: 'smooth' });
        
        // Remove the error message after 5 seconds
        setTimeout(() => {
          errorDiv.remove();
        }, 5000);
      }
    });
  }

  if (phoneInput) {
    // Debounced version of the lookup function (500ms delay)
    const debouncedLookup = debounce((phone) => {
      if (phone.length >= 10) { // Only lookup if we have enough digits
        lookupByPhone(phone);
      }
    }, 500);
    
    // Handle input changes with debounce
    phoneInput.addEventListener('input', (e) => {
      const value = e.target.value.trim();
      
      // Clear immediately if empty or too short
      if (!value || value.length < 5) {
        if (hint) hint.classList.add('d-none');
        lookupData = null;
        return;
      }
      
      // Only trigger lookup for valid phone numbers
      if (/^[0-9+\-\s()]{5,}$/.test(value)) {
        debouncedLookup(value);
      }
    });
    
    // Also check on blur
    phoneInput.addEventListener('blur', () => {
      const value = phoneInput.value.trim();
      if (value && value.length >= 5) {
        lookupByPhone(value);
      }
    });
    
    // Clear on escape key
    phoneInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && hint) {
        hint.classList.add('d-none');
      }
    });
  }

  // Autofill button click
  if (autofillBtn) {
    autofillBtn.addEventListener('click', function() {
      if (!lookupData) return;
      
      const nameEl = document.getElementById('nameInput');
      const emailEl = document.getElementById('emailInput');
      
      if (nameEl && (lookupData.name ?? '') !== '') nameEl.value = lookupData.name;
      if (emailEl && (lookupData.email ?? '') !== '') emailEl.value = lookupData.email;
      
      if (hint) hint.classList.add('d-none');
    });
  }
  // Phone lookup function
  async function lookupByPhone(phone) {
    try {
      const response = await fetch(`/api/visitors/lookup?phone=${encodeURIComponent(phone)}`);
      if (!response.ok) throw new Error('Lookup failed');
      
      const data = await response.json();
      
      if (data.found && autofillHint && nameInput && emailInput) {
        // Show autofill hint
        autofillHint.classList.remove('d-none');
        
        // Set up autofill button
        if (autofillBtn) {
          autofillBtn.onclick = function() {
            if (data.visitor.name) nameInput.value = data.visitor.name;
            if (data.visitor.email) emailInput.value = data.visitor.email;
            autofillHint.classList.add('d-none');
          };
        }
      } else if (autofillHint) {
        autofillHint.classList.add('d-none');
      }
    } catch (error) {
      console.error('Error looking up phone number:', error);
      if (autofillHint) autofillHint.classList.add('d-none');
    }
  }
  
  // Debounce helper function
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
  
  // Update verification status
  function updateVerificationStatus(message, type = 'info') {
    const statusElement = document.getElementById('verificationStatus');
    if (!statusElement) return;
    
    statusElement.textContent = message;
    statusElement.className = `text-${type === 'success' ? 'success' : 
      type === 'error' ? 'danger' : 
      type === 'warning' ? 'warning' : 'info'}`;
    
    // If we have an icon element
    const iconElement = document.getElementById('verificationStatusIcon');
    if (iconElement) {
      iconElement.className = `fas ${type === 'success' ? 'fa-check-circle' : 
        type === 'error' ? 'fa-times-circle' : 
        type === 'warning' ? 'fa-exclamation-triangle' : 'fa-info-circle'}`;
    }
  }
  
  // Initialize face detection when the page loads
  document.addEventListener('DOMContentLoaded', function() {
    // Load face-api.js models
    loadFaceAPIModels().then(() => {
      // Models loaded, we can now enable the start camera button
      if (startBtn) startBtn.disabled = false;
    });
  });
});
</script>
@endpush

@push('scripts')
<script>
// Global variables
let cameraStream = null;

// DOM Elements
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const startBtn = document.getElementById('startCameraBtn');
const captureBtn = document.getElementById('captureBtn');
const retakeBtn = document.getElementById('retakeBtn');
const preview = document.getElementById('preview');
const previewContainer = document.getElementById('previewContainer');
const noPreview = document.getElementById('noPreview');
const faceImageInput = document.getElementById('faceImageInput');
const statusElement = document.getElementById('faceCaptureStatus');

// Start the camera
async function startCamera() {
    try {
        // Stop any existing stream
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
        }
        
        // Request camera access
        cameraStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                width: { ideal: 640 },
                height: { ideal: 480 },
                facingMode: 'user' 
            } 
        });
        
        // Set video source
        video.srcObject = cameraStream;
        await video.play();
        
        // Update UI
        video.style.display = 'block';
        canvas.style.display = 'none';
        startBtn.disabled = true;
        captureBtn.disabled = false;
        retakeBtn.disabled = true;
        previewContainer.style.display = 'none';
        noPreview.style.display = 'block';
        
        updateStatus('Camera started. Position your face in the frame and click Capture.', 'info');
        
    } catch (error) {
        console.error('Camera error:', error);
        updateStatus('Error: ' + (error.message || 'Could not access camera'), 'error');
        startBtn.disabled = false;
    }
}

// Capture the current frame
function capturePhoto() {
    if (!cameraStream) return;
    
    // Set canvas dimensions to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    // Draw current video frame to canvas
    const context = canvas.getContext('2d');
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    // Show the captured image
    const imageData = canvas.toDataURL('image/jpeg');
    preview.src = imageData;
    faceImageInput.value = imageData;
    
    // Update UI
    video.style.display = 'none';
    canvas.style.display = 'block';
    captureBtn.disabled = true;
    retakeBtn.disabled = false;
    previewContainer.style.display = 'block';
    noPreview.style.display = 'none';
    
    updateStatus('Photo captured! Click Retake if needed.', 'success');
}

// Retake photo
function retakePhoto() {
    // Stop the current stream
    if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
    }
    
    // Reset UI
    faceImageInput.value = '';
    previewContainer.style.display = 'none';
    noPreview.style.display = 'block';
    
    // Restart camera
    startCamera();
}

// Update status message
function updateStatus(message, type = 'info') {
    if (!statusElement) return;
    
    statusElement.textContent = message;
    statusElement.className = 'small ' + (
        type === 'error' ? 'text-danger' : 
        type === 'success' ? 'text-success' : 'text-info'
    );
}

// Event Listeners
document.addEventListener('DOMContentLoaded', function() {
    // Set up button event listeners
    if (startBtn) {
        startBtn.addEventListener('click', startCamera);
    }
    
    if (captureBtn) {
        captureBtn.addEventListener('click', capturePhoto);
    }
    
    if (retakeBtn) {
        retakeBtn.addEventListener('click', retakePhoto);
    }
    
    // Clean up on page unload
    window.addEventListener('beforeunload', function() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
        }
    });
});
</script>
@endpush

@endsection
